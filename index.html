<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Flood Visualization - Delhi NCR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 320px;
        }
        
        #ui h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #1e40af;
        }
        
        .info {
            margin: 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        #vrButton {
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        #vrButton:hover { transform: scale(1.05); }
        #vrButton:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .depth-legend {
            margin-top: 15px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        
        .legend-color {
            width: 30px;
            height: 16px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.15);
        }
        
        .controls {
            margin-top: 15px;
            padding: 12px;
            background: #e0f2fe;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid #0ea5e9;
        }
        
        .controls strong {
            display: block;
            margin-bottom: 8px;
            color: #075985;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 18px;
            z-index: 2000;
            text-align: center;
        }
        
        .loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="ui">
        <h2>üåä VR Flood Experience</h2>
        <div class="info">
            <strong>Location:</strong> Delhi NCR<br>
            <strong>Buildings:</strong> <span id="buildingCount">0</span><br>
            <strong>Status:</strong> <span id="status">Loading...</span>
        </div>
        
        <button id="vrButton" disabled>Initializing VR...</button>
        
        <div class="depth-legend">
            <strong>Water Depth:</strong>
            <div class="legend-item"><div class="legend-color" style="background:#bbdefb;"></div><span>&lt; 0.5 m</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#42a5f5;"></div><span>0.5 ‚Äì 1 m</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#1976d2;"></div><span>1 ‚Äì 2 m</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#0d47a1;"></div><span>&gt; 2 m</span></div>
        </div>
        
        <div class="controls">
            <strong>Desktop Controls:</strong>
            ‚Ä¢ Move: WASD / Arrow keys<br>
            ‚Ä¢ Look: Mouse drag<br>
            ‚Ä¢ Up/Down: Space / Shift<br><br>
            <strong>VR Controls:</strong>
            ‚Ä¢ Move: Controller joysticks<br>
            ‚Ä¢ Look: Turn your head<br>
            ‚Ä¢ Exit: Menu button
        </div>
    </div>
    
    <div id="loading">
        <div>Loading 3D environment...</div>
        <div class="loading-bar"><div class="loading-progress" id="progress"></div></div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let waterMeshes = [];
        let buildings = [];
        let isVRActive = false;
        let moveSpeed = 0.1;
        let keys = {};
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        
        const GEOJSON_FILE = 'gridded_30m_T1_flood_only.geojson';
        
        // Reference coordinates for Delhi NCR
        const REFERENCE_LAT = 28.448;
        const REFERENCE_LNG = 77.027;
        
        // Scale factor for converting lat/lng to meters
        const METERS_PER_DEGREE_LAT = 111320;
        const METERS_PER_DEGREE_LNG = METERS_PER_DEGREE_LAT * Math.cos(REFERENCE_LAT * Math.PI / 180);

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 100, 800);
            
            // Camera setup (eye level - 1.6m height)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 1.6, 5);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Lighting - realistic outdoor lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);
            
            const fillLight = new THREE.DirectionalLight(0x9fc5e8, 0.3);
            fillLight.position.set(-100, 50, -100);
            scene.add(fillLight);
            
            // Ground plane (streets/ground level)
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xa89f94,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add some texture to ground with road-like grid
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.8
            });
            
            // Create grid of roads
            for (let i = -500; i <= 500; i += 50) {
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(2000, 8),
                    roadMaterial
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(0, 0.01, i);
                roadH.receiveShadow = true;
                scene.add(roadH);
                
                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(8, 2000),
                    roadMaterial
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(i, 0.01, 0);
                roadV.receiveShadow = true;
                scene.add(roadV);
            }
            
            // Generate procedural buildings based on the area
            generateBuildings();
            
            // VR Button setup
            setupVRButton();
            
            // Desktop controls
            setupDesktopControls();
            
            // Load flood data
            loadFloodData();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }
        
        function generateBuildings() {
            // Create diverse buildings around the area
            const buildingConfigs = [
                // Hospitals (taller, more prominent)
                { x: 80, z: 120, w: 40, d: 30, h: 25, color: 0xffffff, name: 'Hospital' },
                { x: -90, z: 150, w: 35, d: 35, h: 22, color: 0xffffff, name: 'Hospital' },
                
                // Commercial/Office buildings
                { x: 50, z: 50, w: 25, d: 25, h: 35, color: 0xdedede },
                { x: -60, z: 60, w: 30, d: 20, h: 28, color: 0xc8c8c8 },
                { x: 100, z: -40, w: 28, d: 28, h: 32, color: 0xd5d5d5 },
                { x: -80, z: -50, w: 25, d: 30, h: 30, color: 0xcccccc },
                
                // Residential buildings (varied heights)
                { x: 20, z: 80, w: 15, d: 15, h: 18, color: 0xe8d5b7 },
                { x: -30, z: 90, w: 18, d: 12, h: 15, color: 0xdcc8a6 },
                { x: 70, z: -80, w: 12, d: 18, h: 20, color: 0xe0d0b0 },
                { x: -50, z: -70, w: 16, d: 16, h: 16, color: 0xd8c4a0 },
                { x: 110, z: 20, w: 14, d: 14, h: 22, color: 0xe5d8c0 },
                { x: -100, z: 10, w: 20, d: 15, h: 19, color: 0xdac5a8 },
                
                // Shopping centers / Large structures
                { x: 30, z: -30, w: 45, d: 35, h: 12, color: 0xb8b8b8 },
                { x: -70, z: 20, w: 40, d: 30, h: 14, color: 0xc0c0c0 },
                
                // Small shops/houses
                { x: 5, z: 40, w: 10, d: 10, h: 8, color: 0xf0e0d0 },
                { x: -15, z: 35, w: 8, d: 12, h: 9, color: 0xead8c8 },
                { x: 40, z: 10, w: 12, d: 8, h: 7, color: 0xf5e5d5 },
                { x: -40, z: -10, w: 9, d: 9, h: 10, color: 0xe8d8c0 },
                { x: 65, z: 90, w: 11, d: 11, h: 11, color: 0xecd9c5 },
                { x: -85, z: 80, w: 10, d: 13, h: 8, color: 0xf0dcc8 }
            ];
            
            buildingConfigs.forEach((config, index) => {
                const geometry = new THREE.BoxGeometry(config.w, config.h, config.d);
                const material = new THREE.MeshStandardMaterial({ 
                    color: config.color,
                    roughness: 0.7,
                    metalness: 0.2
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(config.x, config.h / 2, config.z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                buildings.push(building);
                
                // Add windows for taller buildings
                if (config.h > 15) {
                    const windowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4a7c9e,
                        emissive: 0x1a3c5e,
                        emissiveIntensity: 0.3
                    });
                    
                    const floors = Math.floor(config.h / 3);
                    for (let f = 1; f < floors; f++) {
                        // Front and back windows
                        for (let w = -config.w/2 + 3; w < config.w/2 - 2; w += 4) {
                            const windowF = new THREE.Mesh(
                                new THREE.BoxGeometry(2, 2, 0.2),
                                windowMaterial
                            );
                            windowF.position.set(config.x + w, f * 3, config.z + config.d/2);
                            scene.add(windowF);
                            
                            const windowB = new THREE.Mesh(
                                new THREE.BoxGeometry(2, 2, 0.2),
                                windowMaterial
                            );
                            windowB.position.set(config.x + w, f * 3, config.z - config.d/2);
                            scene.add(windowB);
                        }
                    }
                }
            });
            
            document.getElementById('buildingCount').textContent = buildings.length;
            updateProgress(33);
        }
        
        function setupDesktopControls() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            
            // Mouse controls for looking around
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => { mouseDown = false; });
            
            window.addEventListener('mousemove', (e) => {
                if (!mouseDown || isVRActive) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                camera.rotation.y -= deltaX * 0.002;
                camera.rotation.x -= deltaY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }
        
        function updateMovement() {
            if (isVRActive) return;
            
            const direction = new THREE.Vector3();
            
            // Forward/backward
            if (keys['w'] || keys['arrowup']) {
                direction.z -= moveSpeed;
            }
            if (keys['s'] || keys['arrowdown']) {
                direction.z += moveSpeed;
            }
            
            // Left/right
            if (keys['a'] || keys['arrowleft']) {
                direction.x -= moveSpeed;
            }
            if (keys['d'] || keys['arrowright']) {
                direction.x += moveSpeed;
            }
            
            // Up/down
            if (keys[' ']) {
                camera.position.y += moveSpeed;
            }
            if (keys['shift']) {
                camera.position.y -= moveSpeed;
            }
            
            // Apply camera rotation to movement
            direction.applyEuler(new THREE.Euler(0, camera.rotation.y, 0));
            camera.position.add(direction);
            
            // Keep above ground
            camera.position.y = Math.max(0.5, camera.position.y);
        }
        
        function setupVRButton() {
            const vrButton = document.getElementById('vrButton');
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.disabled = false;
                        vrButton.textContent = 'Enter VR';
                        vrButton.onclick = toggleVR;
                        updateStatus('VR Ready');
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                        updateStatus('VR not available');
                    }
                });
            } else {
                vrButton.textContent = 'WebXR Not Available';
                updateStatus('Use Desktop Controls');
            }
        }
        
        function toggleVR() {
            if (!isVRActive) {
                renderer.xr.getSession() ? 
                    renderer.xr.getSession().end() :
                    navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor', 'bounded-floor']
                    }).then(onSessionStarted);
            }
        }
        
        function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            renderer.xr.setSession(session);
            isVRActive = true;
            document.getElementById('vrButton').textContent = 'Exit VR';
            document.getElementById('ui').style.display = 'none';
            updateStatus('VR Active');
        }
        
        function onSessionEnded() {
            isVRActive = false;
            document.getElementById('vrButton').textContent = 'Enter VR';
            document.getElementById('ui').style.display = 'block';
            updateStatus('VR Ready');
        }
        
        async function loadFloodData() {
            try {
                updateProgress(50);
                const response = await fetch(GEOJSON_FILE);
                if (!response.ok) {
                    throw new Error('Could not load flood data file');
                }
                const data = await response.json();
                updateProgress(70);
                createWaterFromGeoJSON(data);
                updateProgress(100);
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
                
                updateStatus('Ready - Press WASD to move');
            } catch (error) {
                console.error('Error loading flood data:', error);
                document.getElementById('loading').innerHTML = 
                    '<div>‚ö†Ô∏è Error loading flood data</div><div style="font-size:14px; margin-top:10px;">Place gridded_30m_T1_flood_only.geojson in same folder</div>';
                updateStatus('Error - Using demo mode');
                
                // Create demo water for visualization
                createDemoWater();
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 2000);
            }
        }
        
        function createDemoWater() {
            // Create sample water areas if file not found
            const demoAreas = [
                { x: 0, z: 0, w: 80, d: 60, depth: 0.8 },
                { x: 50, z: 60, w: 50, d: 40, depth: 1.2 },
                { x: -60, z: 50, w: 45, d: 50, depth: 0.6 }
            ];
            
            demoAreas.forEach(area => {
                createSimpleWater(area.x, area.z, area.w, area.d, area.depth);
            });
        }
        
        function createSimpleWater(x, z, width, depth, waterDepth) {
            const geometry = new THREE.PlaneGeometry(width, depth, 32, 32);
            geometry.rotateX(-Math.PI / 2);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    depth: { value: waterDepth },
                    maxDepth: { value: 2.0 }
                },
                vertexShader: `
                    uniform float time;
                    uniform float depth;
                    varying vec2 vUv;
                    varying vec3 vPos;
                    varying float vWave;
                    
                    void main() {
                        vUv = uv;
                        vPos = position;
                        vec3 pos = position;
                        float wave = sin(pos.x * 0.15 + time) * 0.03 + 
                                   sin(pos.z * 0.2 - time * 0.8) * 0.025;
                        vWave = wave;
                        pos.y = depth + wave;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float depth;
                    uniform float maxDepth;
                    varying vec2 vUv;
                    varying vec3 vPos;
                    varying float vWave;
                    
                    vec3 getDepthColor(float d) {
                        if (d < 0.5) return vec3(0.73, 0.87, 0.98);
                        else if (d < 1.0) return vec3(0.26, 0.65, 0.96);
                        else if (d < 2.0) return vec3(0.10, 0.46, 0.82);
                        else return vec3(0.05, 0.28, 0.63);
                    }
                    
                    void main() {
                        vec3 color = getDepthColor(depth);
                        float caustics = sin(vPos.x * 2.0 + time) * cos(vPos.z * 2.0 - time);
                        color += vec3(pow(abs(caustics), 0.8) * 0.15);
                        float highlight = smoothstep(0.015, 0.03, vWave) * 0.25;
                        color += vec3(highlight);
                        gl_FragColor = vec4(color, 0.75);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const water = new THREE.Mesh(geometry, material);
            water.position.set(x, 0, z);
            scene.add(water);
            waterMeshes.push(water);
        }
        
        function createWaterFromGeoJSON(geojsonData) {
            if (geojsonData.type !== 'FeatureCollection') return;
            
            let count = 0;
            let maxDepth = 0;
            
            geojsonData.features.forEach(feature => {
                if (!feature.geometry || !feature.properties) return;
                
                const depth = parseFloat(feature.properties.value);
                if (isNaN(depth) || depth <= 0) return;
                
                maxDepth = Math.max(maxDepth, depth);
                
                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    createWaterPolygon(coords, depth, maxDepth);
                    count++;
                }
            });
            
            console.log(`Created ${count} water bodies. Max depth: ${maxDepth}m`);
        }
        
        function createWaterPolygon(coordinates, depth, maxDepth) {
            const points = coordinates.map(coord => {
                const x = (coord[0] - REFERENCE_LNG) * METERS_PER_DEGREE_LNG;
                const z = -(coord[1] - REFERENCE_LAT) * METERS_PER_DEGREE_LAT;
                return new THREE.Vector2(x, z);
            });
            
            if (points.length < 3) return;
            
            const shape = new THREE.Shape(points);
            const geometry = new THREE.ShapeGeometry(shape, 32);
            geometry.rotateX(-Math.PI / 2);
            
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    depth: { value: depth },
                    maxDepth: { value: maxDepth }
                },
                vertexShader: `
                    uniform float time;
                    uniform float depth;
                    varying vec2 vUv;
                    varying vec3 vPos;
                    varying float vWave;
                    
                    void main() {
                        vUv = uv;
                        vPos = position;
                        vec3 pos = position;
                        float wave = sin(pos.x * 0.1 + time) * 0.02 +
                                   sin(pos.z * 0.15 - time * 0.8) * 0.015 +
                                   sin(pos.x * 0.2 + pos.z * 0.2 + time * 1.5) * 0.01;
                        vWave = wave;
                        pos.y = depth + wave;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float depth;
                    uniform float maxDepth;
                    varying vec2 vUv;
                    varying vec3 vPos;
                    varying float vWave;
                    
                    vec3 getDepthColor(float d) {
                        if (d < 0.5) return vec3(0.73, 0.87, 0.98);
                        else if (d < 1.0) return vec3(0.26, 0.65, 0.96);
                        else if (d < 2.0) return vec3(0.10, 0.46, 0.82);
                        else return vec3(0.05, 0.28, 0.63);
                    }
                    
                    void main() {
                        vec3 color = getDepthColor(depth);
                        float caustics = sin(vPos.x * 2.0 + time) * cos(vPos.z * 2.0 - time);
                        caustics = pow(abs(caustics), 0.8) * 0.3;
                        color += vec3(caustics * 0.2);
                        float highlight = smoothstep(0.01, 0.02, vWave) * 0.3;
                        color += vec3(highlight);
                        float alpha = 0.7 + (depth / maxDepth) * 0.2;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const waterMesh = new THREE.Mesh(geometry, waterMaterial);
            waterMesh.position.y = 0;
            scene.add(waterMesh);
            waterMeshes.push(waterMesh);
        }
        
        function animate() {
            const time = performance.now() * 0.001;
            
            // Update desktop movement
            updateMovement();
            
            // Update water animation
            waterMeshes.forEach(mesh => {
                if (mesh.material.uniforms) {
                    mesh.material.uniforms.time.value = time;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }
        
        function updateProgress(percent) {
            document.getElementById('progress').style.width = percent + '%';
        }
        
        // Initialize the scene
        init();
    </script>
</body>
</html>

