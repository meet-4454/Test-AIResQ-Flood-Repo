<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>360° Flood Panorama – No CORS Issues</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    body { margin:0; overflow:hidden; background:#000; }
    #info { position:absolute; top:15px; left:50%; transform:translateX(-50%); color:#0ff; background:rgba(0,0,0,0.6); padding:10px 20px; border-radius:30px; font-family:Arial; pointer-events:none; z-index:100; }
    #loading { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.9); color:#0ff; padding:25px 50px; border-radius:15px; font-size:22px; font-family:monospace; z-index:1000; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="info">360° Flood View – Drag • VR button for headset</div>
<div id="loading">Loading 360° scene…</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';

// Load MapTiler SDK
const mtScript = document.createElement('script');
mtScript.src = 'https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.js';
document.head.appendChild(mtScript);

const css = document.createElement('link');
css.rel = 'stylesheet';
css.href = 'https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css';
document.head.appendChild(css);

mtScript.onload = startApp;

async function startApp() {
    const API_KEY = '3vyFCdEjKRCq9JRv9kWH';
    const GEOJSON_FILE = 'gridded_30m_T1_flood_only.geojson'; // ← your file here

    maptilersdk.config.apiKey = API_KEY;

    // ────────────────────── Three.js setup ──────────────────────
    const scene   = new THREE.Scene();
    const camera  = new THREE.PerspectiveCamera(90, innerWidth/innerHeight, 0.1, 10000);
    camera.position.y = 20;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    document.body.appendChild(VRButton.createButton(renderer));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.6;

    // ────────────────────── Hidden MapTiler map (CORS-safe style) ──────────────────────
    const mapDiv = document.createElement('div');
    mapDiv.style.cssText = 'position:absolute; left:-9999px; width:1024px; height:1024px;';
    document.body.appendChild(mapDiv);

    const map = new maptilersdk.Map({
        container: mapDiv,
        // THIS IS THE IMPORTANT LINE – CORS-enabled style
        style: `https://api.maptiler.com/maps/streets-v2/style.json?key=${API_KEY}`,
        center: [77.027, 28.448],
        zoom: 17.8,
        pitch: 0,
        bearing: 0,
        interactive: false,
        antialias: true
    });

    let mapTexture, modelTransform;
    const waterGroup = new THREE.Group();
    scene.add(waterGroup);

    map.on('load', () => {
        // 3D buildings
        map.addLayer({
            id: '3d-buildings',
            source: 'composite',
            'source-layer': 'building',
            filter: ['==', 'extrude', 'true'],
            type: 'fill-extrusion',
            paint: {
                'fill-extrusion-color': '#bbbbbb',
                'fill-extrusion-height': ['get', 'height'],
                'fill-extrusion-base': ['coalesce', ['get', 'min_height'], 0],
                'fill-extrusion-opacity': 0.9
            }
        });

        const origin = maptilersdk.MercatorCoordinate.fromLngLat([77.027, 28.448], 0);
        modelTransform = {
            translateX: origin.x,
            translateY: origin.y,
            translateZ: origin.z || 0,
            scale: origin.meterInMercatorCoordinateUnits()
        };

        // Live skybox from the hidden map
        mapTexture = new THREE.CanvasTexture(map.getCanvas());

        const skyGeo = new THREE.SphereGeometry(9000, 60, 40);
        skyGeo.scale(-1, 1, 1);
        const sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({
            map: mapTexture,
            side: THREE.BackSide,
            depthWrite: false
        }));
        scene.add(sky);

        loadFloodData();
    });

    // ────────────────────── Flood water ──────────────────────
    async function loadFloodData() {
        try {
            const r = await fetch(GEOJSON_FILE);
            if (!r.ok) throw new Error('Not found');
            const data = await r.json();
            createWater(data);
            document.getElementById('loading').remove();
        } catch (e) {
            console.error(e);
            document.getElementById('loading').textContent = 'Flood data failed';
        }
    }

    function createWater(geojson) {
        const timeUni = { value: 0 };

        geojson.features.forEach(f => {
            const depth = parseFloat(f.properties?.value || 0);
            if (depth <= 0 || f.geometry.type !== 'Polygon') return;

            const shape = new THREE.Shape();
            f.geometry.coordinates[0].forEach((c, i) => {
                const mc = maptilersdk.MercatorCoordinate.fromLngLat(c);
                const x = (mc.x - modelTransform.translateX) / modelTransform.scale;
                const z = (mc.y - modelTransform.translateY) / modelTransform.scale;
                i===0 ? shape.moveTo(x,z) : shape.lineTo(x,z);
            });

            const geom = new THREE.ShapeGeometry(shape);
            geom.rotateX(-Math.PI/2);

            const mat = new THREE.ShaderMaterial({
                uniforms: { time: timeUni, depth: { value: depth } },
                vertexShader: `
                    uniform float time;
                    void main() {
                        vec3 p = position;
                        float wave = sin(p.x*12.+time*3.)*0.04 + sin(p.z*15.-time*2.5)*0.03;
                        p.y += wave;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
                    }
                `,
                fragmentShader: `
                    uniform float depth;
                    vec3 col(float d){
                        if(d<0.5)return vec3(0.73,0.87,0.98);
                        if(d<1.0)return vec3(0.26,0.65,0.96);
                        if(d<2.0)return vec3(0.10,0.46,0.82);
                        return vec3(0.05,0.28,0.63);
                    }
                    void main(){
                        gl_FragColor = vec4(col(depth), 0.82);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.y = depth;
            waterGroup.add(mesh);
        });
    }

    // ────────────────────── Animation ──────────────────────
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (mapTexture) mapTexture.needsUpdate = true;

        const t = performance.now() * 0.001;
        waterGroup.children.forEach(m => {
            if (m.material.uniforms?.time) m.material.uniforms.time.value = t;
        });

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    animate();
}
</script>
</body>
</html>
